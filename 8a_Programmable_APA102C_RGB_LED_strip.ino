// Tutorial 8a. Programmable APA102C RGB LED strip

// Main parts: Adafruit Metro Mini, APA102C strip 144 x RGB LED

// Library required to drive RGB LEDs; use the latest version
#include "FastLED.h"

// Variables that remain constant
const byte pinData = 4; // Digital output pin to LED strip
const byte pinClock = 3;  // Digital output pin to LED strip
const byte numLeds = 144; // Number of LEDs

// Declare three arrays that store each LED's data. Why three
// arrays? The first array stores each LED's brightness data,
// generated by the shimmer() function below. The second array
// stores each LED's colour data, generated by the paletteTransition()
// function below. The third array stores the combination of the
// two - a "mix" or "blend". This is interesting for running two
// or more different effects independently on a single strip
struct CRGB ledsA[numLeds];
struct CRGB ledsB[numLeds];
struct CRGB ledsResult[numLeds];

// Gradient palette(s) for the paletteTransition() function. See
// https://github.com/FastLED/FastLED/wiki/Gradient-color-palettes
// and http://fastled.io/tools/paletteknife how to create and use
// gradient palettes. One could switch between palettes with a
// momentary switch, some sensor's input, or IoT data
DEFINE_GRADIENT_PALETTE(dummyPalette) {
  0,     0,   0, 255, // Blue
  128,   0, 255,   0, // Green
  255, 255,   0,   0  // Red
};
DEFINE_GRADIENT_PALETTE(auroraBorealis) {
  0,     0, 255,  71,
  96,  255,   1,   8,
  128,  42,  68,  25,
  160,   0, 255,  71,
  255, 255,   1,   8
};
DEFINE_GRADIENT_PALETTE(cumulusClouds) {
  0,   152, 164, 155,
  30,  139, 152, 140,
  64,  126, 141, 128,
  92,   80,  95,  82,
  107,  46,  59,  47,
  114,  74,  88,  71,
  123, 110, 124, 102,
  196,  46,  58,  39,
  255,  11,  18,   8
};

// A flag for each LED's state to keep track of: is it constant or
// is it brightening or is it darkening?
enum {ledConstant, ledBrightens, ledDarkens};
byte ledState[numLeds]; // Declare an array that stores the flags

// Variables that can change
CRGBPalette16 activePalette = cumulusClouds; // Select a palette
byte paletteIndex = 0; // Current colour from the selected palette

// Total gradient palette colour transition time in minutes
// 10 minutes = 2343.75 ms per transition step; 1 hour = 14062.5 ms
const byte transitionDuration = 5;
byte ratio = 128; // Set ledsA's and ledsB's contribution to ledsResult
CRGB darkestColour (16, 16, 16); // Darkest colour to test for
CRGB brightestColour (255, 255, 255); // Brightest colour to test for
CRGB darkenBy (8, 8, 8); // Higher number = LED darkens faster
CRGB brightenBy (16, 16, 16); // Higher number = LED brightens faster

void setup()
{
  // Add the array ledsResult only, because that is the one that will
  // actually be displayed (the result of combining ledsA and ledsB).
  // Note: BGR (not RGB) is the required colour-order for APA102C LEDs
  FastLED.addLeds<APA102, pinData, pinClock, BGR>(ledsResult, numLeds);

  // Set all LED-states to the constant state at start
  memset(ledState, ledConstant, sizeof(ledState));

  // Fill all LEDs in array ledsA with an initial colour
  fill_solid(ledsA, numLeds, darkestColour);

  // Use this when working with clouds or other gradients mainly based
  // on greys; see http://fastled.io/docs/3.1/group___color_enums.html
  FastLED.setTemperature(Halogen);
}

void loop()
{
  // Render effect A (brightness values) into the array ledsA
  shimmer();

  // Render effect B (colours from palette transition) into the array ledsB
  paletteTransition();

  // Go through the LED array one LED at a time and combine each LED's
  // data from array ledsA and array ledsB into array ledsResult
  for (byte i = 0; i < numLeds; i++) {
    ledsResult[i] = blend( ledsA[i], ledsB[i], ratio );
  }

  // Vary the brightness at a certain BPM within a specified range
  LEDS.setBrightness(beatsin8(3, 32, 160));

  // Smaller number = faster retriggering. To not block momentary switch
  // or sensor input, use the non-blocking millis() method instead
  LEDS.delay(40);
}

// Effect A changes each LED's brightness randomly
void shimmer()
{
  // Go through the LED array one LED at a time
  for (byte i = 0; i < numLeds; i++)
  {

    // If the LED is in the constant state
    if ( ledState[i] == ledConstant)
    {
      // Randomly select it (larger number = more shimmer)
      if (random8() < 16)
      {
        // And set it to the brightening state
        ledState[i] = ledBrightens;
      }
    }

    // Otherwise, if the LED is in the brightening state
    else if (ledState[i] == ledBrightens)
    {

      // And it has reached the brightest colour
      if ( ledsA[i] >= brightestColour )
      {
        // Set it to darkening state
        ledState[i] = ledDarkens;
      }
      else
      {
        // Otherwise, continue brightening it
        ledsA[i] += brightenBy;
      }
    }

    else
    {
      // If the LED has reached the darkest colour
      if ( ledsA[i] <= darkestColour )
      {
        // Keep it as it is
        ledsA[i] = darkestColour;
        // And set it to the constant state so it could be randomly
        // selected for brightening during the next iteration
        ledState[i] = ledConstant;
      }
      else
      {
        // Otherwise, continue darkening it
        ledsA[i] -= darkenBy;
      }
    }
  }
}

// Effect B changes each LED's colour based on the selected palette
void paletteTransition() {

  // Calculate gradient palette transition steps (in milliseconds)
  static const float interval = ((float)(transitionDuration * 60) / 256) * 1000;

  // Then, fetch a colour from the gradient palette
  CRGB colour = ColorFromPalette(activePalette, paletteIndex, 160, LINEARBLEND);

  // And fill all LEDs in array ledsB with that colour
  fill_solid(ledsB, numLeds, colour);

  // Every transition step, a new interpolated colour is fetched
  EVERY_N_MILLISECONDS(interval)
  {
    // Proceed to the next interpolated colour
    if (paletteIndex < 255)
    {
      paletteIndex++;
    }

    // Wrap around back to zero at the end
    if (paletteIndex == 255)
    {
      paletteIndex = 0;
    }
  }
}
